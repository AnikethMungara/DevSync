#!/usr/bin/env bash
set -euo pipefail

# killdev
# Finds common dev server PIDs (by listening ports and by common process names)
# and kills them. Supports --dry-run and --yes to skip confirmation.

PORTS=(3000 5173 3001 8000 5000 4200 9229)
NAMES=(node pnpm yarn npm)

DRY_RUN=0
ASSUME_YES=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --dry-run) DRY_RUN=1; shift ;;
    --yes|-y) ASSUME_YES=1; shift ;;
    --help|-h)
      cat <<EOF
Usage: $(basename "$0") [--dry-run] [--yes]

Options:
  --dry-run    Show what would be killed, do not terminate processes.
  --yes, -y    Do not prompt for confirmation, kill immediately.
  -h, --help   Show this help message.
EOF
      exit 0
      ;;
    *) echo "Unknown option: $1"; exit 2 ;;
  esac
done

found_pids=()

find_pids_by_port() {
  local port=$1
  local pids=""
  if command -v lsof >/dev/null 2>&1; then
    pids=$(lsof -ti tcp:"$port" 2>/dev/null || true)
  elif command -v ss >/dev/null 2>&1; then
    # ss output parsing: local_address:port  users:("/proc/<pid>/exe",pid=<pid>,fd=..)
    pids=$(ss -ltnp 2>/dev/null | awk -v p=":$port" '$4~p {gsub(/.*pid=/,"",$0); match($0,/pid=[0-9]+/); if (RSTART) { pid=substr($0,RSTART+4,RLENGTH-4); print pid }}' || true)
  else
    # fallback to netstat
    if netstat -tunlp 2>/dev/null | grep -q ":$port\b" 2>/dev/null; then
      pids=$(netstat -tunlp 2>/dev/null | grep ":$port\b" | awk '{print $7}' | sed 's#/.*##' | sort -u)
    fi
  fi
  echo "$pids"
}

find_pids_by_name() {
  local name=$1
  local pids=""
  if command -v pgrep >/dev/null 2>&1; then
    pids=$(pgrep -f "$name" || true)
  else
    # fallback: ps + grep
    pids=$(ps aux 2>/dev/null | grep "$name" | grep -v grep | awk '{print $2}' || true)
  fi
  echo "$pids"
}

echo "Looking for processes listening on ports: ${PORTS[*]}"
for port in "${PORTS[@]}"; do
  pids=$(find_pids_by_port "$port")
  if [[ -n "$pids" ]]; then
    for pid in $pids; do
      found_pids+=("$pid")
    done
  fi
done

echo "Looking for common dev process names: ${NAMES[*]}"
for name in "${NAMES[@]}"; do
  pids=$(find_pids_by_name "$name")
  if [[ -n "$pids" ]]; then
    for pid in $pids; do
      found_pids+=("$pid")
    done
  fi
done

# Unique PIDs
unique_pids=($(printf "%s\n" "${found_pids[@]}" | sort -n -u))

if [[ ${#unique_pids[@]} -eq 0 ]]; then
  echo "No matching dev server processes found."
  exit 0
fi

echo "Found PIDs: ${unique_pids[*]}"

if [[ $DRY_RUN -eq 1 ]]; then
  echo "Dry run enabled â€” no processes will be terminated."
  exit 0
fi

if [[ $ASSUME_YES -ne 1 ]]; then
  read -r -p "Kill the above processes? [y/N] " ans
  case "$ans" in
    [Yy]*) ;;
    *) echo "Aborted."; exit 0 ;;
  esac
fi

echo "Attempting graceful termination..."
for pid in "${unique_pids[@]}"; do
  if [[ "$OSTYPE" == "msys"* || "$OSTYPE" == "cygwin"* || "$OSTYPE" == "win32"* ]]; then
    # On Git Bash / Cygwin on Windows, use taskkill to ensure process is stopped
    if command -v taskkill >/dev/null 2>&1; then
      cmd.exe /C "taskkill /F /PID $pid" >/dev/null 2>&1 || true
    else
      kill -TERM "$pid" >/dev/null 2>&1 || true
    fi
  else
    kill -TERM "$pid" >/dev/null 2>&1 || true
  fi
  # Wait a moment and escalate if still there
  sleep 0.2
  if kill -0 "$pid" >/dev/null 2>&1; then
    echo "PID $pid did not exit, forcing kill..."
    if [[ "$OSTYPE" == "msys"* || "$OSTYPE" == "cygwin"* || "$OSTYPE" == "win32"* ]]; then
      cmd.exe /C "taskkill /F /PID $pid" >/dev/null 2>&1 || true
    else
      kill -KILL "$pid" >/dev/null 2>&1 || true
    fi
  else
    echo "PID $pid terminated."
  fi
done

echo "Done."
